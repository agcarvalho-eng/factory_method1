:imagesdir: ../../images/patterns/criacionais
:source-highlighter: highlightjs
:numbered:
:unsafe:
:icons: font

ifdef::env-github[]
:outfilesuffix: .adoc
:caution-caption: :fire:
:important-caption: :exclamation:
:note-caption: :paperclip:
:tip-caption: :bulb:
:warning-caption: :warning:
endif::[]

= Padr√µes de Projetos Criacionais

IMPORTANT: https://www.youtube.com/watch?v=6I5rGX3k_J4&list=PLyo0RUAM69UtO8Jjq71qgvRxcI2pTrB2m&index=8&t=0s[V√≠deo-aula sobre o padr√£o.]

== Factory Method (M√©todo F√°brica)

=== Defini√ß√£o

// tag::definicao[]
üìò"Fornece uma interface para criar um objeto, mas permite √†s subclasses decidirem qual tipo de objeto instanciar." [UCPP]
// end::definicao[]

=== Aplicabilidade

Podemos utilizar o padr√£o quando:

// tag::aplicabilidade1[]
- uma classe precisa utilizar um tipo de objeto, mas ela n√£o tem como decidir qual tipo concreto utilizar, pois tal l√≥gica √© definida por subclasses;
- cada subclasse tem uma l√≥gica diferente para a cria√ß√£o dos objetos (juntar estas l√≥gicas na superclasse tornaria o c√≥digo extenso e confuso);
// end::aplicabilidade1[]
// tag::aplicabilidade2[]
- novas subclasses puderem ser introduzidas a qualquer momento com diferentes l√≥gicas;
- voc√™ n√£o conhece todos os tipos concretos de objetos que podem ser criados;
- √© necess√°rio criar objetos por meio de **composi√ß√£o**, cada objeto instanciado √© um **todo** composto por diferentes **partes**, tais partes devem ser escolhidas de acordo com o todo.
// end::aplicabilidade2[]

=== Modelagem

.Modelagem do Factory Method
image::factory-method.png[]

`TipoAbstrato` √© uma interface ou classe abstrata/super classe que representa o tipo dos objetos que a f√°brica pode criar.
As classes `TipoConcreto1` at√© `TipoConcretoN` representam os tipos concretos que podem ser instanciados de fato pela f√°brica.
`CriadorAbstrato` representa a implementa√ß√£o base da f√°brica. Ela pode ter quaisquer m√©todos que forem necess√°rios,
incluindo um m√©todo abstrato `newObject()` que dever√° ser implementados pelos criadores concretos.

A classe `CriadorAbstrato` normalmente ter√° um m√©todo que chamar√° o `newObject()` para usar o objeto criado.
Neste exemplo, tal m√©todo √© o `useObject()`, mas em uma implementa√ß√£o real, o m√©todo deve ter um nome de acordo 
com o problema sendo resolvido.

Diferente da Simple Factory:

- a l√≥gica que define qual objeto ser√° instanciado n√£o √© centralizada em uma classe, mas sim nas subclasses de `CriadorAbstrato`;
- logo, o m√©todo `newObject()` √© abstrato, pois as subclasses de `CriadorAbstrato` √© que o implementar√£o.
- tal m√©todo n√£o deve ser est√°tico se ele for usado por outros m√©todos da classe (como √© o caso deste modelo);

Cada subclasse de `CriadorAbstrato` √© que definir√° a l√≥gica para a instancia√ß√£o do objeto representado por `TipoAbstrato`.
Para a Simple Factory n√£o existem subclasses.

Um projeto de exemplo para o diagrama apresentado est√° dispon√≠vel link:modelagem[aqui]. Ele deve ser alterado para incluir as mudan√ßas necess√°rias para o problema espec√≠fico que voc√™ estiver resolvendo com o padr√£o.

=== Princ√≠pios utilizados

==== Single-Responsitility Principle

Com o https://en.wikipedia.org/wiki/Single-responsibility_principle[Single-Responsitility Principle (SRP)], a classe `CriadorAbstrato` de fato n√£o cria os objetos, apenas define um m√©todo que as filhas devem implementar para isto.
Ela apenas usar√° os objetos criados. Cada subclasse ter√° a responsabilidade de criar tais objetos.

==== Open-Closed Principle

Com o https://en.wikipedia.org/wiki/Open‚Äìclosed_principle[Open/Closed Principle (OCP)], separamos as partes que mudam, i.e. a l√≥gica de cria√ß√£o de objetos, de dentro da classe que utiliza tais objetos. Isto torna a classe que utiliza a factory "aberta para extens√£o e fechada para modifica√ß√£o".

==== Programar para uma "interface" n√£o uma implementa√ß√£o

https://tuhrig.de/programming-to-an-interface/[Programar para uma "interface" n√£o uma implementa√ß√£o] (GoF) indica que devemos declar vari√°veis com tipos abstratos (`TipoAbstrato`) e usar tipos concretos apenas na instancia√ß√£o (`SubTipo1` ... `SubTipoN`).

==== Dependency Inversion Principle (DIP)

Ao aplicar o https://en.wikipedia.org/wiki/Dependency_inversion_principle[Dependency Inversion Principle (DIP)], a classe `CriadorAbstrato` n√£o depende de tipos concretos, mas sim de tipos abstratos (interfaces ou classes abstratas).
Ela n√£o precisa saber quais s√£o os tipos concretos existentes.

=== Remodelando o projeto Exportador Produto com a Simple Factory

Antes de implementarmos o padr√£o Factory Method, precisamos
voltar ao projeto anterior, para fazer algumas altera√ß√µes
considerando um novo cen√°rio.

Os detalhes s√£o fornecidos no projeto link:exportador-problematico[exportador-problematico].

=== Exemplos

Podemos utilizar o Factory Method para encapsular a instancia√ß√£o de colunas de uma tabela em formato espec√≠fico,
baseado no projeto link:../simple-factory/exportador-simple-factory-reflection[exportador-simple-factory-reflection].
Implemente o projeto seguindo a modelagem abaixo:

.Factory Method para a instancia√ß√£o de colunas de uma tabela em formato espec√≠fico
image::factory-method-exportador.png[]

O c√≥digo fonte do projeto est√° dispon√≠vel link:exportador-factory-method-reflection[aqui] (link:https://kinolien.github.io/gitzip/?download=/manoelcampos/padroes-projetos/tree/master/criacionais/factory-method/exportador-factory-method-reflection[zip]).

=== Detalhes de Implementa√ß√£o

xxxxxxxxxxxx

== Problemas da **N√ÉO** utiliza√ß√£o do padr√£o

Veja o projeto link:exportador-problematico[exportador-problematico] (link:https://kinolien.github.io/gitzip/?download=/manoelcampos/padroes-projetos/tree/master/criacionais/factory-method/exportador-problematico[zip]).
Ele √© uma implementa√ß√£o do exportador de dados sem utilizar o padr√£o Factory Method,
seguindo a modelagem do diagrama abaixo:

.Exportador de dados que N√ÉO usa o padr√£o Factory Method
image::no-factory-method-exportador-produtos.png[]

== Padr√µes Relacionados

Padr√µes que possuem similaridades ou podem ser usados em conjunto:

- link:../simple-factory[Simple Factory]
- link:../../comportamentais/template-method[Template Method]
